package com.tibco.sb.mongodb;

import java.net.URL;
import java.util.concurrent.TimeUnit;

import org.bson.Document;

import com.mongodb.Block;
import com.mongodb.ConnectionString;
import com.mongodb.MongoClientSettings;
import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCursor;
import com.mongodb.connection.ServerSettings;
import com.mongodb.connection.SocketSettings;
import com.streambase.sb.*;
import com.streambase.sb.operator.*;
import com.tibco.sb.mongodbUtil.MongoMonitorClass;
import com.tibco.sb.mongodbUtil.SharedMongoClient;

/**
 * Generated by JDT StreamBase Client Templates (Version: 10.5.0.1911151605).
 *
 * This class is used as a Java Operator in a StreamBase application. One
 * instance will be created for each Java Operator in a StreamBase application.
 * <p>
 * Enqueue methods should only be called from processTuple.
 * 
 * @see Parameterizable
 * @see Operator For in-depth information on implementing a custom Java
 *      Operator, please see "Developing StreamBase Java Operators" in the
 *      StreamBase documentation.
 */
public class Mongo extends Operator implements Parameterizable {

	public static final long serialVersionUID = 1610337096284L;
	// Properties
	private String InsertSchema;
	private String Url;
	private String DB;
	private String collection;
	private int connectionTimeOutMs;
	private int socketTimeOutMs;
	private int serverSelectionTimeoutMs;
	private int maxConnPool;
	private int minConnPool;
	private boolean sharedClient;
	private boolean monitorConnection;
	private String displayName = "Mongodb";
	// Local variables
	private int inputPorts = 1;
	private int outputPorts = 1;
	private Schema[] outputSchemas; // caches the Schemas given during init() for use at processTuple()
	private Schema outputSchema;
	private MongoCore mCore = null;

	/**
	 * The constructor is called when the Operator instance is created, but before
	 * the Operator is connected to the StreamBase application. We recommended that
	 * you set the initial input port and output port count in the constructor by
	 * calling setPortHints(inPortCount, outPortCount). The default is 1 input port,
	 * 1 output port. The constructor may also set default values for operator
	 * parameters. These values will be displayed in StreamBase Studio when a new
	 * instance of this operator is dragged to the canvas, and serve as the default
	 * values for omitted optional parameters.
	 */
	public Mongo() {
		super();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		setUrl("mongodb://localhost:27017");
		setDB("default");
		setCollection("default");
		setConnectionTimeOutMs(300000);
		setSocketTimeOutMs(30000);
		setServerSelectionTimeoutMs(30000);
		setSharedClient(false);
		setMonitorConnection(false);
	}

	/**
	 * The typecheck method is called after the Operator instance is connected in
	 * the StreamBase application, allowing the Operator to validate its properties.
	 * The Operator class may change the number of input or output ports by calling
	 * the requireInputPortCount(portCount) method or the setOutputSchema(schema,
	 * portNum) method. If the verifyInputPortCount method is passed a different
	 * number of ports than the Operator currently has, a PortMismatchException
	 * (subtype of TypecheckException) is thrown.
	 */
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		Schema read = getInputSchema(0);
		if (read != null) {
			if (!read.hasField("Filter")) {
				throw new TypecheckException("Read Input does not contain Filter / ID");
			} else if (!read.hasField("Collection")) {
				throw new TypecheckException("Missing field\"Collection\"");
			} else if (!read.hasField("Command")) {
				throw new TypecheckException("Missing field\"Command\"");
			} else if (!read.hasField("Filter")) {
				throw new TypecheckException("Missing field \"Filter\"");
			}
		}

		setOutputSchema(0, new MongoCore().createOutputSchema(read));

		if (isMonitorConnection()) {
			setOutputSchema(1, MongoMonitorClass.getSchema());
		}
	}

	private void generateAndRespond(String ID, String Collection, Document data, Tuple inTuple, Throwable err) throws StreamBaseException {

		Tuple t = getOutputSchema(0).createTuple();

		if (ID != null) {
			t.setString("ID", ID);
		}
		if (data != null) {
			t.setString("Data", data.toJson());
		}
		t.setString("Collection", Collection);
		if (err != null) {
			t.setBoolean("Error", true);
			t.setString("ErrorMessage", err.getMessage());
		} else {
			t.setBoolean("Error", false);
		}

		// set inputTuple
		t.setTuple("PassThrough", inTuple);

		if (data != null || err != null) {
			sendOutput(0, t);
		}
	}

	private void runTimeCheck(Tuple tuple, String[] types) throws StreamBaseException {
		for (String type : types) {
			if (tuple.isNull(type)) {
				throw new StreamBaseException("Expected " + type + " to be a non-null value");
			}
		}
	}

	@Override
	public Schema[] getProposedInputSchemas(String mainName) {
		Schema sch = new Schema("MongoInput", new Schema.Field[] {
//						Schema.createField(DataType.STRING, "InsertSchema"),
				Schema.createField(DataType.STRING, "ID"), Schema.createField(DataType.STRING, "Command"),
				Schema.createField(DataType.STRING, "Collection"), Schema.createField(DataType.STRING, "Filter"),
				Schema.createField(DataType.STRING, "Data"),
				Schema.createListField("DataList", CompleteDataType.forString()) });
		return new Schema[] { sch };
	}

	/**
	 * This method will be called by the StreamBase server for each Tuple given to
	 * the Operator to process. This is the only time an operator should enqueue
	 * output Tuples.
	 * 
	 * @param inputPort the input port that the tuple is from (ports are zero based)
	 * @param tuple     the tuple from the given input port
	 * @throws StreamBaseException Terminates the application.
	 */
	public void processTuple(int inputPort, Tuple tuple) throws StreamBaseException {
		if (getLogger().isInfoEnabled()) {
			getLogger().info("operator processing a tuple at input port" + inputPort);
		}
		// TODO only the first input port is processed; see the template code for
		// typecheck()
		if (inputPort > 0) {
			getLogger().info("operator skipping tuple at input port" + inputPort);
			return;
		}

		runTimeCheck(tuple, new String[] { "ID", "Command" });
		final String ID = tuple.isNull("ID") ? null : tuple.getString("ID");
		final String cmd = tuple.getString("Command").toLowerCase();
		final String Collection = tuple.getString("Collection");

		// Result Document init
		Document ret = null;

		if (cmd.equals("insert")) {
			runTimeCheck(tuple, new String[] { "Collection", "Data" });
			mCore.insertData(tuple.getString("Collection"), tuple.getString("Data"));
			generateAndRespond(ID, Collection, Document.parse(tuple.getString("Data")), tuple, null);

		} else if (cmd.equals("read")) {
			runTimeCheck(tuple, new String[] { "Collection", "Filter" });
			FindIterable<Document> retIter = mCore.getData(tuple.getString("Collection"), tuple.getString("Filter"));

			try (MongoCursor<Document> cursor = retIter.iterator()) {
				while (cursor.hasNext()) {
					generateAndRespond(ID, Collection, cursor.next(), tuple, null);
				}
			} catch (Exception e) {
				// TODO Auto-generated catch block
				generateAndRespond(ID, Collection, ret, tuple, e);
				e.printStackTrace();
			}

		} else if (cmd.equals("update") || cmd.equals("upsert")) {
			runTimeCheck(tuple, new String[] { "Filter", "Data" });
//			try {
				ret = mCore.updateData(tuple.getString("Collection"), tuple.getString("Filter"), cmd.equals("upsert"),
						tuple.getString("Data"));
				generateAndRespond(ID, Collection, ret, tuple, null);
//			} catch (Exception e) {
//				// TODO Auto-generated catch block
//				generateAndRespond(ID, Collection, ret, tuple, e);
//				e.printStackTrace();
//			}
		} else if (cmd.equals("findoneandupdate")) {
			runTimeCheck(tuple, new String[] { "Collection", "Filter", "Data" });
//			try {
				ret = mCore.findOneAndUpdate(tuple.getString("Collection"), tuple.getString("Filter"),
						tuple.getString("Data"));
				generateAndRespond(ID, Collection, ret, tuple, null);
//			} catch (Exception e) {
//				// TODO Auto-generated catch block
//				generateAndRespond(ID, Collection, ret, tuple, e);
//				e.printStackTrace();
//			}
		} else if (cmd.equals("delete")) {
			runTimeCheck(tuple, new String[] { "Collection", "Filter" });
//			try {
				ret = mCore.deleteData(tuple.getString("Collection"), tuple.getString("Filter"));
				generateAndRespond(ID, Collection, ret, tuple, null);
//			} catch (Exception e) {
//				// TODO Auto-generated catch block
//				generateAndRespond(ID, Collection, ret, tuple, e);
//				e.printStackTrace();
//			}
		} else if (cmd.equals("bulkinsert")) {
			runTimeCheck(tuple, new String[] { "Collection", "ID", "DataList" });
			ret = mCore.bulkinsert(tuple.getString("Collection"),
					tuple.getList("DataList").toArray(new String[tuple.getList("DataList").size()]));
			generateAndRespond(ID, Collection, ret, tuple, null);
		} else {
			throw new StreamBaseRuntimeException("Unknown command : " + cmd);
		}
	}

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase
	 * application is started. Note that your Operator class is not required to
	 * define the init method, unless (for example) you need to perform
	 * initialization of a resource such as a JDBC pool, if your operator is making
	 * JDBC calls. StreamBase Studio does not call this during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();
		// for best performance, consider caching input or output Schema.Field objects
		// for
		// use later in processTuple()
		outputSchemas = new Schema[outputPorts];

		ConnectionString connectionString = new ConnectionString(Url);

		MongoClientSettings settings = MongoClientSettings.builder().applyConnectionString(connectionString)
				.applyToConnectionPoolSettings(builder -> builder.maxSize(maxConnPool).minSize(minConnPool))
				.applyToSocketSettings(new Block<SocketSettings.Builder>() {
					@Override
					public void apply(final SocketSettings.Builder builder) {
						// TODO Auto-generated method stub
						// https://scalegrid.io/blog/understanding-mongodb-client-timeout-options/
						builder.connectTimeout(connectionTimeOutMs, TimeUnit.MICROSECONDS).readTimeout(socketTimeOutMs,
								TimeUnit.MICROSECONDS);
					}
				}).build();

		MongoClient c = null;
		if (sharedClient) {
			SharedObjectManager shom = this.getRuntimeEnvironment().getSharedObjectManager();
			SharedMongoClient shc = (SharedMongoClient) shom.getSharedObject(Url);
			if (shc == null) {
				c = MongoClients.create(settings);
				shc = new SharedMongoClient(getUrl());
				shom.registerSharedObject(getUrl(), shc);
				shc.startObject(); // Connect to the DB.
			}
			c = shc.getClient();
		} else {
			c = MongoClients.create(settings);
			if (isMonitorConnection()) {
				ConnectionString cString = new ConnectionString(getUrl());
				ServerSettings.builder().applyConnectionString(cString)
						.addServerMonitorListener(new MongoMonitorClass((t) -> {
							try {
								sendOutputAsync(1, t);
							} catch (StreamBaseException e) {
								e.printStackTrace();
							}
						})).build();
			}
		}
		for (int i = 0; i < outputPorts; ++i) {
			outputSchemas[i] = getRuntimeOutputSchema(i);
		}
		mCore = new MongoCore(c, collection, DB);
	}

	/**
	 * The shutdown method is called when the StreamBase server is in the process of
	 * shutting down.
	 */
	public void shutdown() {

	}

	@Override
	public URL getIconResource(IconKind iconType) {
		switch (iconType) {
		case CANVAS_OVERLAY_ICON:
			return getClass().getResource("mongodb_s.png");
		case PALETTE_ICON_LARGE:
			return getClass().getResource("mongodb_l.png");
		case PALETTE_ICON_SMALL:
			return getClass().getResource("mongodb_s.png");
		default:
			return null;
		}
	}

	/***************************************************************************************
	 * The getter and setter methods provided by the Parameterizable object. *
	 * StreamBase Studio uses them to determine the name and type of each property *
	 * and obviously, to set and get the property values. *
	 ***************************************************************************************/

	public void setInsertSchema(String InsertSchema) {
		this.InsertSchema = InsertSchema;
	}

	public String getInsertSchema() {
		return this.InsertSchema;
	}

	public void setUrl(String Url) {
		this.Url = Url;
	}

	public String getUrl() {
		return this.Url;
	}

	public void setDB(String DB) {
		this.DB = DB;
	}

	public String getDB() {
		return this.DB;
	}

	public void setCollection(String collection) {
		this.collection = collection;
	}

	public String getCollection() {
		return this.collection;
	}

	public void setConnectionTimeOutMs(int connectionTimeOutMs) {
		this.connectionTimeOutMs = connectionTimeOutMs;
	}

	public int getConnectionTimeOutMs() {
		return this.connectionTimeOutMs;
	}

	public void setSocketTimeOutMs(int socketTimeOutMs) {
		this.socketTimeOutMs = socketTimeOutMs;
	}

	public int getSocketTimeOutMs() {
		return this.socketTimeOutMs;
	}

	public void setServerSelectionTimeoutMs(int serverSelectionTimeoutMs) {
		this.serverSelectionTimeoutMs = serverSelectionTimeoutMs;
	}

	public int getServerSelectionTimeoutMs() {
		return this.serverSelectionTimeoutMs;
	}

	public void setSharedClient(boolean sharedClient) {
		this.sharedClient = sharedClient;
	}

	public boolean getSharedClient() {
		return this.sharedClient;
	}

	public void setMonitorConnection(boolean monitorConnection) {
		this.monitorConnection = monitorConnection;
	}

	public boolean getMonitorConnection() {
		return this.monitorConnection;
	}

	public boolean isMonitorConnection() {
		return monitorConnection;
	}

	public int getMaxConnPool() {
		return maxConnPool;
	}

	public void setMaxConnPool(int maxConnPool) {
		this.maxConnPool = maxConnPool;
	}

	public int getMinConnPool() {
		return minConnPool;
	}

	public void setMinConnPool(int minConnPool) {
		this.minConnPool = minConnPool;
	}

	/**
	 * For detailed information about shouldEnable methods, see interface
	 * Parameterizable java doc
	 * 
	 * @see Parameterizable
	 */

	public boolean shouldEnableInsertSchema() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableUrl() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableDB() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableCollection() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableConnectionTimeOutMs() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableSocketTimeOutMs() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableServerSelectionTimeoutMs() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableSharedClient() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableMonitorConnection() {
		// TODO implement custom enablement logic here
		return true;
	}

}
